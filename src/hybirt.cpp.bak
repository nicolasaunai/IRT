#include "vecfield.hpp"
#include "field.hpp"

#include "faraday.hpp"
#include "ampere.hpp"
#include "ohm.hpp"
#include "utils.hpp"
#include "gridlayout.hpp"
#include "boundary_condition.hpp"
#include "moments.hpp"
#include "pusher.hpp"
#include "diagnostics.hpp"
#include "population.hpp"

#include "highfive/highfive.hpp"

#include <iostream>
#include <array>
#include <vector>
#include <cstdint>
#include <memory>
#include <algorithm>

// Average scalar field
template<std::size_t dimension>
void average(Field<dimension> const& F1, Field<dimension> const& F2, Field<dimension>& Favg)
{
    std::transform(F1.begin(), F1.end(), F2.begin(), Favg.begin(),
                   [](double a, double b) { return 0.5 * (a + b); });
}

// Average vector field
template<std::size_t dimension>
void average(VecField<dimension> const& V1, VecField<dimension> const& V2, VecField<dimension>& Vavg)
{
    average(V1.x, V2.x, Vavg.x);
    average(V1.y, V2.y, Vavg.y);
    average(V1.z, V2.z, Vavg.z);
}

// Magnetic field initializers
double bx(double x) { return 0.0; }
double by(double x) { return 1.0; }
double bz(double x) { return 0.0; }
double density(double x) { return 1.0; }

void magnetic_init(VecField<1>& B, GridLayout<1> const& layout)
{
    for (auto ix = layout.primal_dom_start(Direction::X); ix <= layout.primal_dom_end(Direction::X); ++ix)
        B.x(ix) = bx(layout.coordinate(Direction::X, Quantity::Bx, ix));

    for (auto ix = layout.dual_dom_start(Direction::X); ix <= layout.dual_dom_end(Direction::X); ++ix) {
        double x = layout.coordinate(Direction::X, Quantity::By, ix);
        B.y(ix) = by(x);
        B.z(ix) = bz(x);
    }
}

int main()
{
    double time = 0.;
    double final_time = 10.0;
    double dt = 0.001;
    constexpr std::size_t dimension = 1;

    std::array<std::size_t, dimension> grid_size = {100};
    std::array<double, dimension> cell_size = {0.2};
    constexpr std::size_t nbr_ghosts = 1;
    constexpr std::size_t nppc = 100;

    auto layout = std::make_shared<GridLayout<dimension>>(grid_size, cell_size, nbr_ghosts);

    // Allocate fields
    VecField<dimension> E{layout, {Quantity::Ex, Quantity::Ey, Quantity::Ez}};
    VecField<dimension> B{layout, {Quantity::Bx, Quantity::By, Quantity::Bz}};
    VecField<dimension> Enew{layout, {Quantity::Ex, Quantity::Ey, Quantity::Ez}};
    VecField<dimension> Bnew{layout, {Quantity::Bx, Quantity::By, Quantity::Bz}};
    VecField<dimension> Eavg{layout, {Quantity::Ex, Quantity::Ey, Quantity::Ez}};
    VecField<dimension> Bavg{layout, {Quantity::Bx, Quantity::By, Quantity::Bz}};
    VecField<dimension> J{layout, {Quantity::Jx, Quantity::Jy, Quantity::Jz}};
    VecField<dimension> V{layout, {Quantity::Vx, Quantity::Vy, Quantity::Vz}};
    Field<dimension> N{layout->allocate(Quantity::N), Quantity::N};

    auto boundary_condition = BoundaryConditionFactory<dimension>::create("periodic", layout);

    std::vector<Population<dimension>> populations;
    populations.emplace_back("main", layout);

    for (auto& pop : populations)
        pop.load_particles(nppc, density);

    magnetic_init(B, *layout);
    boundary_condition->fill(B);

    Faraday<dimension> faraday{layout, dt};
    Ampere<dimension> ampere{layout};
    Ohm<dimension> ohm{layout};
    Boris<dimension> push{layout, dt};

    ampere(B, J);
    boundary_condition->fill(J);

    for (auto& pop : populations) {
        pop.deposit();
        boundary_condition->fill(pop.flux());
        boundary_condition->fill(pop.density());
    }

    total_density(populations, N);
    bulk_velocity<dimension>(populations, N, V);
    ohm(B, J, N, V, E);
    boundary_condition->fill(E);

    diags_write_fields(B, E, V, N, time, HighFive::File::Truncate);
    diags_write_particles(populations, time, HighFive::File::Truncate);

    while (time < final_time)
    {
        std::cout << "Time: " << time << " / " << final_time << "\n";

        // ------------------
        // Step 1: E, B â†’ Enew, Bnew
        // ------------------
        Bnew = B;
        Enew = E;
        faraday(E, Bnew);
        boundary_condition->fill(Bnew);

        // CORRECTED PUSHER CALL
        for (auto& pop : populations) {
            auto& particle_vector = pop.particles();
            push(particle_vector, E, Bnew);
        }

        for (auto& pop : populations) {
            pop.deposit();
            boundary_condition->fill(pop.flux());
            boundary_condition->fill(pop.density());
        }

        total_density(populations, N);
        bulk_velocity<dimension>(populations, N, V);
        ohm(Bnew, J, N, V, Enew);
        boundary_condition->fill(Enew);

        // ------------------
        // Step 2: averaging
        // ------------------
        average(E, Enew, Eavg);
        average(B, Bnew, Bavg);

        faraday(Eavg, Bnew);
        boundary_condition->fill(Bnew);

        // CORRECTED PUSHER CALL
        for (auto& pop : populations) {
            auto& particle_vector = pop.particles();
            push(particle_vector, Eavg, Bnew);
        }

        for (auto& pop : populations) {
            pop.deposit();
            boundary_condition->fill(pop.flux());
            boundary_condition->fill(pop.density());
        }

        total_density(populations, N);
        bulk_velocity<dimension>(populations, N, V);
        ohm(Bnew, J, N, V, Eavg);
        boundary_condition->fill(Eavg);

        // Final assignment
        B = Bnew;
        E = Eavg;

        time += dt;

        diags_write_fields(B, E, V, N, time);
        std::cout << "**********************************\n";
    }

    return 0;
}



// In pusher.hpp

void operator()(std::vector<Particle<dimension>>& particles,
                VecField<dimension> const& E,
                VecField<dimension> const& B) override
{
    // Calculate domain width for periodic boundaries
    double const domain_width = this->layout_->grid_size(Direction::X) * this->layout_->cell_size(Direction::X);

    for (auto& particle : particles)
    {
        // Leapfrog: half-step position update (this part is unchanged)
        particle.position[0] += 0.5 * particle.v[0] * this->dt_;

        // --- (Boris velocity rotation logic remains the same here) ---

        // Interpolate fields...
        double dx = this->layout_->cell_size(Direction::X);
        int iCell = static_cast<int>(particle.position[0] / dx);
        double rem = (particle.position[0] / dx) - iCell;

        double Ex = this->interpolate(E.x, iCell, rem);
        double Ey = this->interpolate(E.y, iCell, rem);
        double Ez = this->interpolate(E.z, iCell, rem);

        double Bx = this->interpolate(B.x, iCell, rem);
        double By = this->interpolate(B.y, iCell, rem);
        double Bz = this->interpolate(B.z, iCell, rem);

        // ...
        // (The entire velocity update calculation is unchanged)
        // ...

        // Half electric field acceleration: v_minus = v + (q E dt / 2m)
        double vx_minus = particle.v[0] + 0.5 * particle.charge * Ex * this->dt_ / particle.mass;
        double vy_minus = particle.v[1] + 0.5 * particle.charge * Ey * this->dt_ / particle.mass;
        double vz_minus = particle.v[2] + 0.5 * particle.charge * Ez * this->dt_ / particle.mass;

        // Boris rotation
        double tx = 0.5 * particle.charge * Bx * this->dt_ / particle.mass;
        double ty = 0.5 * particle.charge * By * this->dt_ / particle.mass;
        double tz = 0.5 * particle.charge * Bz * this->dt_ / particle.mass;

        double t2 = tx * tx + ty * ty + tz * tz;
        double sx = 2.0 * tx / (1.0 + t2);
        double sy = 2.0 * ty / (1.0 + t2);
        double sz = 2.0 * tz / (1.0 + t2);

        // v'
        double vpx = vx_minus + (vy_minus * tz - vz_minus * ty);
        double vpy = vy_minus + (vz_minus * tx - vx_minus * tz);
        double vpz = vz_minus + (vx_minus * ty - vy_minus * tx);

        // v+
        double vx_plus = vx_minus + (vpy * sz - vpz * sy);
        double vy_plus = vy_minus + (vpz * sx - vpx * sz);
        double vz_plus = vz_minus + (vpx * sy - vpy * sx);

        // Final half acceleration from E field
        particle.v[0] = vx_plus + 0.5 * particle.charge * Ex * this->dt_ / particle.mass;
        particle.v[1] = vy_plus + 0.5 * particle.charge * Ey * this->dt_ / particle.mass;
        particle.v[2] = vz_plus + 0.5 * particle.charge * Ez * this->dt_ / particle.mass;


        // Final half-step position update
        particle.position[0] += 0.5 * particle.v[0] * this->dt_;

        // --- NEW: APPLY PERIODIC PARTICLE BOUNDARY CONDITIONS ---
        if (particle.position[0] >= domain_width)
        {
            particle.position[0] -= domain_width;
        }
        else if (particle.position[0] < 0.0)
        {
            particle.position[0] += domain_width;
        }
    }
}




